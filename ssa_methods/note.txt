utils.activate_I2C_chip()



ssa.pwr.off()

ssa.pwr.mainpoweron()

time.sleep(0.2); ssa.pwr.set_pvdd( 1.2 )
time.sleep(0.2); ssa.pwr.set_dvdd( 1.2 )
time.sleep(0.2); ssa.pwr.set_avdd( 1.2 )

ssa.pwr.get_power()
ssa.pwr.reset()
ssa.pwr.get_power()


ssa.try_i2c()




hex(ssa.ctrl.I2C.peri_write( register = 'mask_strip', field = False, data=0xff))
hex(ssa.ctrl.I2C.peri_read(  register = 'mask_strip', field = False))


for i in range(120):
    p1 = random.randint(1,255)
    p2 = random.randint(1,255)
    time.sleep(0.01); hex(ssa.ctrl.I2C.strip_write( strip = 50, register = 'DigCalibPattern_L', field = False, data=p1 ))
    time.sleep(0.01); hex(ssa.ctrl.I2C.strip_write( strip = 50, register = 'DigCalibPattern_H', field = False, data=p2 ))
    time.sleep(0.01); r1 = ssa.ctrl.I2C.strip_read(  strip = 50, register = 'DigCalibPattern_L', field = False )
    time.sleep(0.01); r2 = ssa.ctrl.I2C.strip_read(  strip = 50, register = 'DigCalibPattern_H', field = False )
    #time.sleep(0.01); print('{:s}, {:s}'.format(r1,r2))
    if(p1 == r1): print('OK {:d}'.format(r1))
    else:         print('ER {:d}'.format(r1))
    if(p2 == r2): print('OK {:d}'.format(r2))
    else:         print('ER {:d}'.format(r2))
    print('---------------------------')


ssa.ctrl.init_slvs(current=0b111)
ssa.pwr.get_power()

bin(ssa.ctrl.I2C.peri_write(register = 'mask_strip',  field = False, data=0xff))
bin(ssa.ctrl.I2C.peri_write(register = 'mask_peri_D', field = False, data=0xff))
bin(ssa.ctrl.I2C.peri_write(register = 'mask_peri_A', field = False, data=0xff))


for i in range(120):
    p1 = random.randint(1,255)
    p2 = random.randint(1,255)
    time.sleep(0.01); hex(ssa.ctrl.I2C.strip_write( strip = i, register = 'DigCalibPattern_L', field = False, data=p1 ))
    time.sleep(0.01); hex(ssa.ctrl.I2C.strip_write( strip = i, register = 'DigCalibPattern_H', field = False, data=p2 ))
    time.sleep(0.01); r1 = ssa.ctrl.I2C.strip_read(  strip = i, register = 'DigCalibPattern_L', field = False )
    time.sleep(0.01); r2 = ssa.ctrl.I2C.strip_read(  strip = i, register = 'DigCalibPattern_H', field = False )
    #time.sleep(0.01); print('{:s}, {:s}'.format(r1,r2))
    if(p1 == r1): print('OK {:d}'.format(r1))
    else:         print('ER {:d}'.format(r1))
    if(p2 == r2): print('OK {:d}'.format(r2))
    else:         print('ER {:d}'.format(r2))
    print('---------------------------')


# MASK ##################################################
bin(ssa.ctrl.I2C.peri_write(register = 'mask_strip',  field = False, data=0xff))
bin(ssa.ctrl.I2C.peri_write(register = 'mask_peri_D', field = False, data=0xff))
bin(ssa.ctrl.I2C.peri_write(register = 'mask_peri_A', field = False, data=0xff))
bin(ssa.ctrl.I2C.peri_read(register = 'mask_strip',  field = False))
bin(ssa.ctrl.I2C.peri_read(register = 'mask_peri_D', field = False))
bin(ssa.ctrl.I2C.peri_read(register = 'mask_peri_A', field = False))
#######################################################################


#termination ##################################################
bin(ssa.ctrl.I2C.peri_write(register = 'SLVS_pad_current_Clk_T1',  field = False, data=0b11111111))
#######################################################################



#SLVS ##################################################
ssa.ctrl.init_slvs(current=0b111)
#######################################################################


# alignment ###########################################################
self = ssa.ctrl
bin(ssa.ctrl.I2C.peri_write(register = 'control_1',  field = False, data=0b11010))
self.set_shift_pattern([0x80]*8)
ssa.readout.all_lines()
ssa.ctrl.align_out()
ssa.readout.all_lines()
bin(ssa.ctrl.I2C.peri_write(register = 'control_1',  field = False, data=0b11000))
#######################################################################



#######################################################################
ssa.pwr.get_power()

bin(ssa.ctrl.I2C.peri_read(register = 'control_2',  field = False))

#config strip
for i in range(0, 120):
    ssa.i2c.strip_write(register="StripControl1", field=False, strip=i, data=0b0)

ssa.i2c.strip_write(register="StripControl1", field=False, strip=1, data=0b1001)
ssa.i2c.strip_write(register="StripControl1", field=False, strip=2, data=0b1001)
ssa.i2c.strip_write(register="StripControl1", field=False, strip=3, data=0b1001)
ssa.i2c.strip_write(register="StripControl1", field=False, strip=4, data=0b1001)
ssa.i2c.strip_write(register="StripControl1", field=False, strip=5,  data=0b1001)
ssa.i2c.strip_write(register="StripControl1", field=False, strip=6, data=0b1001)
ssa.i2c.strip_write(register="StripControl1", field=False, strip=7, data=0b1001)
ssa.i2c.strip_write(register="StripControl1", field=False, strip=8, data=0b1001)

ssa.readout.all_lines(l1data=1, cluster=0)
ssa.readout.l1_data(display_raw=1, display=1)

bin(ssa.i2c.strip_read(register="StripControl1", field=False, strip=60) )

#calpulse duration
bin(ssa.ctrl.I2C.peri_write(register = 'control_2',  field = False, data= 0b11110101))
bin(ssa.ctrl.I2C.peri_read(register = 'control_2',  field = False))

#######################################################################
hex(ssa.i2c.peri_read(register="Bias_THDAC", field=False))
ssa.i2c.peri_write(register="Bias_THDAC", field=False, data=5)

#######################################################################



###### contatori #####################3
ssa.i2c.strip_write(register="StripControl1", field=False, strip=50, data=0b00011101)
ssa.i2c.strip_write(register="StripControl1", field=False, strip=51, data=0b00011101)
ssa.i2c.strip_write(register="StripControl1", field=False, strip=52, data=0b00011101)
ssa.i2c.strip_write(register="StripControl1", field=False, strip=53, data=0b00011101)

ssa.i2c.peri_write(register="Bias_THDAC", field=False, data=5)
hex(ssa.i2c.peri_read(register="Bias_THDAC", field=False))

ssa.i2c.peri_write(register="Bias_CALDAC", field=False, data=100)
hex(ssa.i2c.peri_read(register="Bias_CALDAC", field=False))

bin(ssa.ctrl.I2C.peri_write(register = 'control_1',  field = False, data= 0b11001 ))
bin(ssa.ctrl.I2C.peri_read(register = 'control_1',  field = False ))

Configure_TestPulse_SSA(50,50,500, 1000 ,0,0,0)

ssa_cal.fc7.open_shutter(2);
ssa_cal.fc7.SendCommand_CTRL("start_trigger");
ssa_cal.fc7.close_shutter(2);

ssa.i2c.strip_read( register="AC_ReadCounterLSB", field=False, strip=50)
ssa.i2c.strip_read( register="AC_ReadCounterLSB", field=False, strip=51)
ssa.i2c.strip_read( register="AC_ReadCounterLSB", field=False, strip=52)


##### BIST ####################################################


time.sleep(0.2); ssa.pwr.set_dvdd( 0.82 )

time.sleep(0.001); bin(ssa.ctrl.I2C.peri_write(register = 'mask_strip',  field = False, data=0xff))
time.sleep(0.001); bin(ssa.ctrl.I2C.peri_write(register = 'mask_peri_D', field = False, data=0xff))
time.sleep(0.001); bin(ssa.ctrl.I2C.peri_write(register = 'mask_peri_A', field = False, data=0xff))


def BIST_LOOP():
    time.sleep(0.001); ssa.pwr.reset(display=False)
    time.sleep(0.001); bin(ssa.ctrl.I2C.peri_write(register = 'mask_strip',  field = False, data=0xff))
    time.sleep(0.001); bin(ssa.ctrl.I2C.peri_write(register = 'mask_peri_D', field = False, data=0xff))
    time.sleep(0.001); bin(ssa.ctrl.I2C.peri_write(register = 'mask_peri_A', field = False, data=0xff))
    # bin(ssa.ctrl.I2C.peri_read(register = 'mask_peri_D', field = False))
    # bin(ssa.ctrl.I2C.peri_read(register = 'mask_peri_A', field = False))
    time.sleep(0.001);  bin(ssa.i2c.peri_read(register="bist_output", field=False))
    time.sleep(0.001);  bin(ssa.i2c.peri_read(register="ClkTree_control", field=False))
    time.sleep(0.001);  bin(ssa.ctrl.I2C.peri_write(register = 'ClkTree_control', field = False, data=0b01010100))
    error = 0
    for i in range(100000):
        time.sleep(0.001);  bin(ssa.ctrl.I2C.peri_write(register = 'bist_memory_sram_mode',  field = False, data= 0x00 ))
        time.sleep(0.001);  bin(ssa.ctrl.I2C.peri_write(register = 'bist_memory_sram_start', field = False, data= 0x00 ))
        time.sleep(0.001);  bin(ssa.ctrl.I2C.peri_write(register = 'bist_memory_sram_mode',  field = False, data= 0x0f ))
        time.sleep(0.001);  hex(ssa.i2c.peri_read(register="bist_memory_sram_mode", field=False))
        time.sleep(0.001);  bin(ssa.ctrl.I2C.peri_write(register = 'bist_memory_sram_start', field = False, data= 0x0f ))
        #time.sleep(0.001); hex(ssa.i2c.peri_read(register="bist_memory_sram_start", field=False))
        #time.sleep(0.001); hex(ssa.i2c.peri_read(register="bist_output", field=False))
        time.sleep(0.001);
        for N in range(0,16):
            reg = "bist_memory_sram_output_L_{:X}".format(N)
            r = ssa.i2c.peri_read(register=reg, field=False)
            if( r != 0 ):
                error += 1
                print( str(N) + '--' + bin(r))
        print('-----------------------')
        print(error)


BIST_LOO





#if((tbconfig.VERSION['SSA'] >= 2))
#	print("Mask test:")
#	for iter in range(repeat):
#		data = randint(1,255)
#		d.append( data )
#		for k in range(8):
#			field = 'b{:0d}'.format(k)
#			w.append( self.I2C.peri_write(register = 'configuration_test', field = field, data = data))










utils.activate_I2C_chip()
self.fc7.SendCommand_CTRL("stop_trigger")
self.ssa.readout.cluster_data(initialize=True)
self.ssa.ctrl.activate_readout_async()
time.sleep(0.001)
self.ssa.readout.read_counters_fast([], shift=0, initialize=True)

self.fc7.close_shutter(8)
self.fc7.clear_counters(8)
self.ssa.strip.set_cal_strips(mode = 'counter', strip = 'all')
self.ssa.ctrl.set_cal_pulse(amplitude = cal_val, duration = 15, delay = 'keep')
self.ssa.ctrl.set_threshold(threshold);  # set the threshold

self.fc7.clear_counters(8, 5)
self.fc7.open_shutter(8, 5)
self.fc7.SendCommand_CTRL("start_trigger")
self.fc7.close_shutter(8,5)

failed, couters = self.ssa.readout.read_counters_fast(striplist, shift = countershift, initialize = 0)
#failed, couters = self.ssa.readout.read_counters_i2c(striplist)



def scurves(self, cal_ampl = [50], mode = 'all', nevents = 1000, rdmode = 'fast', display = False, plot = True, filename = 'TestLogs/Chip-0', filename2 = '', msg = "", striplist = range(1,121), speeduplevel = 2, countershift = 0, set_trim = False, d19c_firmware_issue_repeat = True, start_threshold = 0):
    '''	cal_ampl  -> int |'baseline'  -> Calibration pulse charge (in CALDAC LSBs)
        mode      -> 'all' | 'sbs'   -> All strips together or one by one
        nevents   -> int number      -> Number of calibration pulses (default 1000)
        striplist -> [list 1:120]    -> Select specific strip (default all)
        rdmode    -> 'fast' | 'i2c'  -> Select if use fast readout or I2C readout
        display   -> True | False    -> Display additional informations
        plot      -> True | False    -> Plot S-Curve
        filename  -> False | string  -> If not False the data is vritten in the file named by 'string'
        filename2 -> 'string'        -> Additional string to complete the filename
        msg       -> internal use
    '''
    #self.fc7.reset()
    evaluate_sc = True
    evaluate_cn = 0
    while(evaluate_sc):
        evaluate_cn += 1
        time_init = time.time()
        utils.activate_I2C_chip()
        # first go to the async mode
        self.fc7.SendCommand_CTRL("stop_trigger")
        self.ssa.readout.cluster_data(initialize=True)
        self.ssa.ctrl.activate_readout_async()
        ermsg = ''
        baseline = False
        if isinstance(cal_ampl, int):
            cal_ampl = [cal_ampl]
        elif cal_ampl == 'baseline':
            baseline = True
            cal_ampl = [0]
            if(set_trim):
                self.set_trimming(0, display=False)
                self.set_trimming(31, striplist, display=False)
                time.sleep(0.001)
        elif not isinstance(cal_ampl, list):
            utils.print_error("-> ssa_cal_utility/scurves wrong cal_alpl parameter")
            return False
        if(rdmode == 'fast'):
            self.ssa.readout.read_counters_fast([], shift=0, initialize=True)
        #Configure_TestPulse_MPA_SSA(200, nevents)# init firmware cal pulse
        Configure_TestPulse_SSA(50,50,500,nevents,0,0,0)

        for cal_val in  cal_ampl:
            # close shutter and clear counters
            self.fc7.close_shutter(8)
            self.fc7.clear_counters(8)
            # init chip cal pulse
            self.ssa.strip.set_cal_strips(mode = 'counter', strip = 'all')
            self.ssa.ctrl.set_cal_pulse(amplitude = cal_val, duration = 15, delay = 'keep')

            #Configure_TestPulse_MPA_SSA(200, nevents)
            #Configure_TestPulse_SSA(50,50,500,1000,0,0,0)

            # then let's try to measure the scurves
            scurves = np.zeros((256,120), dtype=np.int)
            threshold = start_threshold
            utils.ShowPercent(0, 256, "Calculating S-Curves "+msg+" ")
            while (threshold < 256):
                time_cur = time.time()
                strout = ""
                error = False
                #print("Setting the threshold to ", threshold, ", sending the test pulse and reading the counters")
                strout += "threshold = " + str(threshold) + ".   "
                self.ssa.ctrl.set_threshold(threshold);  # set the threshold
                #time.sleep(0.05);
                if (not baseline and (mode == 'all')):	# provide cal pulse to all strips together
                    self.fc7.clear_counters(8, 5)
                    self.fc7.open_shutter(8, 5)
                    #Configure_TestPulse_SSA(50,50,500,1000,0,0,0)
                    #Configure_TestPulse_MPA(200, 200, 200, nevents, enable_L1 = 0, enable_rst = 0, enable_init_rst = 0)
                    self.fc7.SendCommand_CTRL("start_trigger") # send sequence of NEVENTS pulses
                    test = 1
                    t = time.time()
                    timeout = 500
                    while (test):
                        timeout-=1
                        if(timeout<=0):
                            test=0; break
                        test = (self.fc7.read("stat_fast_fsm_state"))
                        time.sleep(0.001)
                        #print(test,)
                        if((not test) and (((time.time()-t)*1E3)<2) ): # D19C firmware issue
                            time.sleep(0.005)
                            test = self.fc7.read("stat_fast_fsm_state")
                            if(not test):
                                self.fc7.SendCommand_CTRL("start_trigger")
                                t = time.time()
                                test = 1
                    #print(((time.time()-t)*1E3))
                    self.fc7.close_shutter(8,5)
                elif(not baseline and (mode == 'sbs')): # provide cal pulse strip by strip
                    self.fc7.clear_counters(1)
                    for s in striplist:
                        self.ssa.strip.set_cal_strips(mode = 'counter', strip = s )
                        time.sleep(0.01);
                        self.fc7.open_shutter(2); time.sleep(0.01);
                        self.fc7.SendCommand_CTRL("start_trigger"); time.sleep(0.01); # send sequence of NEVENTS pulses
                        while(self.fc7.read("stat_fast_fsm_state") != 0):
                            time.sleep(0.01)
                        self.fc7.close_shutter(2); time.sleep(0.01);

                elif(baseline and (mode == 'all')):
                    self.fc7.clear_counters(2); #time.sleep(0.01);
                    self.fc7.open_shutter(2);   #time.sleep(0.01);
                    self.fc7.close_shutter(2);  #time.sleep(0.01);

                elif(baseline and (mode == 'sbs')):
                    # with this method, the time between open and close shutter
                    # change from strip to strip due to the communication time
                    # so do not use to compare the counters value,
                    # from the point of view of the atandard deviation is not influent
                    self.fc7.clear_counters(2); time.sleep(0.01);
                    for s in striplist:
                        # all trims at 0 and one at 31 to remove the crosstalks effect
                        if(set_trim):
                            self.ssa.strip.set_trimming('all', 0)
                            self.ssa.strip.set_trimming(s, 31)
                        time.sleep(0.01);
                        self.fc7.open_shutter(2);  time.sleep(0.01);
                        self.fc7.close_shutter(2); time.sleep(0.01);
                if(rdmode == 'fast'):
                    failed, scurves[threshold] = self.ssa.readout.read_counters_fast(striplist, shift = countershift, initialize = 0)
                elif(rdmode == 'i2c'):
                    failed, scurves[threshold] = self.ssa.readout.read_counters_i2c(striplist)
                else:
                    failed = True

                if (failed):
                    error = True; ermsg = '[Counters readout]';
                else:
                    if(d19c_firmware_issue_repeat):
                        for s in range(0,120):
                            if ((threshold > 0) and (scurves[threshold,s])==0 and (scurves[threshold-1,s]>(nevents*0.8)) ) :
                                error = True; ermsg = '[Condition 1]' + str(scurves[threshold,s]) +'  ' + str(scurves[threshold-1,s])
                            elif ((not baseline) and (threshold > 10) and (scurves[threshold,s])== 2*scurves[threshold-1,s] and (scurves[threshold,s] != 0)):
                                error = True; ermsg = '[Condition 2]'

                if (error == True):
                    threshold = (threshold-1) if (threshold>0) else 0
                    utils.ShowPercent(threshold, 256, "Failed to read counters for threshold " + str(threshold) + ". Redoing. " +  ermsg)
                    #time.sleep(0.5)
                    continue
                else:
                    strout += "Counters samples = 1->[" + str(scurves[threshold][0]) + "]  30->[" + str(scurves[threshold][29]) + "]  60->[" + str(scurves[threshold][59]) + "]  90->[" + str(scurves[threshold][89]) + "]  120->[" + str(scurves[threshold][119]) + "]"

                if(speeduplevel >= 2 and threshold > 32):
                    if( (scurves[threshold-8: threshold ] == np.zeros((8,120), dtype=np.int)).all() ):
                        break

                if (display == True):
                    utils.ShowPercent(threshold, 256, strout)
                else:
                    utils.ShowPercent(threshold, 256, "Calculating S-Curves "+msg+"                                      ")
                threshold = threshold + 1

            utils.ShowPercent(256, 256, "Done calculating S-Curves "+msg+"                                            ")

            if( isinstance(filename, str) ):
                fo = "../SSA_Results/" + filename + "_scurve_" + filename2 + "__cal_" + str(cal_val) + ".csv"
                CSV.ArrayToCSV (array = scurves, filename = fo, transpose = True)
                utils.print_log( "->  Data saved in" + fo)

        if(np.sum(scurves[:,10:110] )<100):
            if(evaluate_cn>4):
                utils.print_error("-X\tError in S-Curve evaluation {:d}".format(np.sum(scurves[50:100,:])))
                return False
            utils.print_warning("-X\tIssue in S-Curve evaluation. Reiterating.. {:d}".format(np.sum(scurves[50:100,:])))
        else: evaluate_sc = False
    for i in range(120):
        if(np.sum(scurves[:,i])==0):
            utils.print_warning("X>\tScurve consant to 0 for strip {:d}".format(i))
    #### print("\n\n" , (time.time()-time_init))
    if(plot == True): plt.clf()
    plt.ylim(0,3000); plt.xlim(0,150);
    plt.plot(scurves)
    if(plot == True): plt.show()
    self.scurve_data     = scurves
    self.scurve_nevents  = nevents
    self.scurve_calpulse = cal_ampl
    return scurves
